package com.tp.ques;

/**
 * @author chenfeifei8090@100.me
 * @program timo
 * @date 2020-10-20 13:58
 * @desc
 **/
public class Q4 {

    /**
     * 递归三要素
     * 1、定义递归函数功能
     * 2、寻找结束条件
     * 3、寻找等价关系
     *
     * 1、明确递归终止条件；
     * 2、给出递归终止时的处理办法；
     * 3、提取重复的逻辑，缩小问题规模。
     *
     *f = n =>
     *  n === 1 ? 1
     *  : n * f(n-1)
     * f 里面用到了 f，怎么理解呢？
     * 很简单，把式子展开即可：先递，再归
     * f(6)
     * => 6 * f(5)
     * => 6 * (5 * f(4))
     * => 6 * (5 * (4 * f(3)))
     * => 6 * (5 * (4 * (3 * f(2))))
     * => 6 * (5 * (4 * (3 * (2 * f(1)))))
     * => 6 * (5 * (4 * (3 * (2 * 1))))
     * => 6 * (5 * (4 * (3 * 2)))
     * => 6 * (5 * (4 * 6))
     * => 6 * (5 * 24)
     * => 6 * 120
     * => 720
     *
     * 一个小朋友坐在第10排，他的作业本被小组长扔到了第1排，小朋友要拿回他的作业本，可以怎么办？他可以拍拍第9排小朋友，说“帮我拿第1排的本子”，而第9排的小朋友可以拍拍第8排        小朋友，说“帮我拿第1排的本子”...如此下去，消息终于传到了第1排小朋友那里，于是他把本子递给第2排，第2排又递给第3排...终于，本子到手啦！这就是递归，拍拍小朋友的背可         以类比函数调用，而小朋友们都记得要传消息、送本子，是因为他们有记忆力，这可以类比栈。
     *
     *
     * f(8)
     * f(x-1)+f(x-2)
     * f(7)+f(6)+f(5)+f(4)+f(3)+f(2)+f(1)
     */

    /**
     * 100个台阶，一次走一步，走两步，走三步，有多少种可能?
     */

    static int goAddThree(int x){
        if (x == 1){
            return 1;
        }
        else if (x == 2){
            return 2;
        }
        else if (x == 3){
            return 4;
        }
        else{
            return goAddThree(x - 1) + goAddThree(x-2)+goAddThree(x-3);
        }

    }

    public static int addTwo(int n){
        if(n<=2){
            return n;
        }
        int x = addTwo(n-1)+addTwo(n-2);
        System.out.println(n-1 + "::" +(n-2));
        return x;
    }



    /**
     * 一个11层的楼梯，每次能走一步、两步三步，第九级台阶坏了，问走到顶层有多少种方法?
     * a(n)=a(n-1)+a(n-2)+a(n-3)
     * a(1)=1,a(2)=2,a(3)=4
     * 现状再考虑第九级台阶坏了，有：
     * a(4)=7
     * a(5)=13
     * a(6)=24
     * a(7)=44
     * a(8)=81
     * a(10)=a(7)+a(8)=125
     * a(11)=a(8)+a(10)=206
     * 所以，上到顶层有206种走法。
     *
     */

    public static void main(String[] args) {
        System.out.println(goAddThree(10));
    }

}
